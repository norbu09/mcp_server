# Product Context: MCP Server Elixir Library\n\n## 1. Problem Solved\n\nModern AI applications often involve complex interactions between a user-facing application and various backend models or services (e.g., Large Language Models, tool providers). The Model Context Protocol (MCP) aims to standardize these interactions, providing a common language for how context (resources, prompts, capabilities) is exchanged.\n\nCurrently, Elixir developers wanting to implement an MCP server would need to build the protocol handling from scratch. This involves:\n\n*   Parsing and validating JSON-RPC requests specific to MCP.\n*   Managing connection state (e.g., initialized client capabilities).\n*   Dispatching MCP method calls to appropriate application logic.\n*   Formatting responses according to the MCP specification.\n*   Integrating this logic with web servers (like Bandit via Plug).\n\nThis boilerplate is time-consuming and error-prone, distracting from the core task of building the actual AI capabilities.\n\n## 2. How It Should Work (User Experience)\n\nAn Elixir developer should be able to integrate MCP server functionality into their application with minimal effort:\n\n1.  **Add Dependency:** Add `mcp_server` to their `mix.exs` dependencies.\n2.  **Define a Handler:** Create an Elixir module that `use MCPServer.Implementation` and implements the necessary callbacks for their specific MCP logic (e.g., `list_resources/2`, `execute_tool/3`).\n3.  **Mount the Plug:** In their Plug-based application (e.g., Phoenix router or application supervision tree with Bandit), mount `MCPServer.Plug`, configuring it with their handler module.\n\n```elixir\n# Example: Phoenix Router\ndefmodule MyAppWeb.Router do\n  use MyAppWeb, :router\n\n  forward \"/mcp\", MCPServer.Plug, mcp_handler: MyApp.MyMCPServerHandler\nend\n\n# Example: Handler Implementation\ndefmodule MyApp.MyMCPServerHandler do\n  use MCPServer.Implementation\n  require Logger\n\n  @impl MCPServer.Implementation\n  def init(opts, _conn_abstraction) do\n    Logger.info(\"Initializing MyMCPServerHandler with opts: \#{inspect(opts)}\")\n    {:ok, %{init_opts: opts}}\n  end\n\n  @impl MCPServer.Implementation\n  def list_resources(filter, state, _conn_abstraction) do\n    Logger.info(\"Listing resources with filter: \#{inspect(filter)}\")\n    resources = [\n      # ... application-specific resource definitions ...\n      %{id: \"default_chat\", name: \"Default Chat\", type: \"chat\", operations: [\"prompt\"]}\n    ]\n    {:reply, resources, state}\n  end\n\n  # ... other callbacks ...\nend\n```\n\nThe library should handle all the underlying MCP protocol details, letting the developer focus on their application\'s unique features.\n\n## 3. User Experience Goals\n\n*   **Simplicity:** Easy to understand, integrate, and use.\n*   **Idiomatic Elixir:** Feels natural to Elixir developers, leveraging behaviours, GenServers, and Plug conventions.\n*   **Clear Abstraction:** Hides the complexity of the MCP JSON-RPC layer.\n*   **Good Documentation:** Comprehensive guides and API references.\n*   **Debuggability:** Provides useful logging and error messages.\n*   **Performance:** Efficient enough for typical web application loads (though not a primary focus over correctness and usability for the initial version).\n 